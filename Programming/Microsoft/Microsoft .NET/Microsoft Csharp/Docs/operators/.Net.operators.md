# operators

- [C# operators](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/index)
- [C# 运算符](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/index)
- [c# 优化代码的一些规则——判断 null 值得不同写法[六] - 梦里小探花 - 博客园](https://www.cnblogs.com/aoximin/archive/2004/01/13/13024286.html)

## 常用

### 1. 非空运算符

```c#
Request?.Browser?.Browser??""

UserItem userItem = new UserItem();
var aa = userItem?.PassItem?.Pass ?? "";
if (userItem?.PassItem?.Pass == "1")
{
}
else
{
}
userItem.PassItem = new PassItem();
var bb = userItem?.PassItem?.Pass ?? "";
userItem.PassItem = new PassItem() { Pass = "111" };
var cc = userItem?.PassItem?.Pass ?? "";
if (userItem?.PassItem?.Pass == "111")
{
}
else
{
}

// 那么在c#6.0中，handle?.invoke(this);
// 这是写为什么就线程安全？
// 安装字面理解还是如果不为null，然后执行啊，有啥区别。
// 问题就是在c# 运行这个的时候是一个整体，如果handle不为空，就去执行invoke，而不是下一条语句。
// 怎么说啊，因为c#是解释型语言代码是一条一条运行的，也就是说c# 运行的最下单位是一条语句。

```
